.. _parray:

PArray
======

.. cpp:class:: PArray

  Located in :boxlib:`Src/C_BaseLib/PArray.H`.

  The ``PArray<T>`` class is similar to the :cpp:class:`Array` class
  except that it implements an array of pointers to objects of type
  ``T`` rather than an array of the objects themselves.  As with
  ``Array<T> objects``, ``PArray<T>`` objects know about their length,
  can be dynamically resized and have built-in automatic bounds
  checking.

  .. warning::

    When a ``PArray<T>`` object is destructed, whether the objects to
    which it points will be deleted depends on its memory management
    policy.  The default memory management policy is not to delete.
    That is, by default, the pointers are *non-owning*.

  **Constructors and copy assignment operator**

    .. cpp:function:: explicit PArray(PArrayPolicy _managed=PArrayNoManage)

      Constructs a ``PArray`` with no elements.  The default memory
      management policy is not to delete the underlying objects upon
      destruction.
    
    .. cpp:function:: explicit PArray(int len, PArrayPolicy \\
		      _managed=PArrayNoManage)

       Constructs a ``PArray`` of length len of null pointers.  The
       default memory management policy is not to delete the
       underlying objects upon destruction.

    .. cpp:function:: PArray(const PArray<T>& rhs)

      Because of the memory management issue, this copy constructor
      should **NOT** be used explicitly in any codes.  But, having the
      copy constructor allows us to construct ``Array< PArray<T> >``
      objects.

    .. cpp:function:: PArray<T>& operator=(const PArray<T>& rhs)

      Because of the memory management issue, this copy assignment
      operator should **NOT** be used explicitly in any codes.  But,
      having the copy constructor allows us to write codes like
      below:: 

        Array< PArray <MultiFab> > mfs;
	f(mfs);  // call function f

	// definition of function f
        void f(Array< PArray <MultiFab> >& mfs;
        {
          mfs.resize(2); // resize requires copy assignment operator
        }

  **Destructor**

    .. cpp:function:: ~PArray()

      If the memory management policy is ``PArrayManage``, this destructor
      delete all objects pointed by the pointers in this array.

  **Member functions**

    .. cpp:function:: bool defined(int i) const

      Returns true if the ``i``'th element is not the null pointer.

    .. cpp:function:: T& operator[] (int i)
                      const T& operator[] (int i) const

      Return a reference to the object pointed to by the ``i``'th
      element.

    .. cpp:function:: void set(int i, T* elem)
                      void set(int i, const T* elem)

      Defines the ``i``'th element of this ``PArray<T>`` to the
      pointer value elem.  If the memory management policy is
      ``PArrayManage``, it is an error if the i'th element
      previously had a non-null value.

    .. cpp:function:: int size() const

      Returns the number of elements.

    .. cpp:function:: void clear()

      This function sets each pointer in this ``PArray<T>`` to null.
      If the memory management policy is ``PArrayManage``, this
      function will also delete all objects pointed by the pointers
      in this array.

    .. cpp:function:: void clear(int i)

      This function sets the ``i``'th pointer in this ``PArray<T>`` to
      null.  If the memory management policy is ``PArrayManage``, this
      function will also delete the object pointed by the ``i``'th
      pointer.

    .. cpp:function:: void resize(int newsize)

      This function changes the size of the array to ``newsize`` while
      preserving the value of as many array elements as possible.  If
      ``newsize`` is greater than the current length, the array is
      grown and the new elements are null pointers.  If newsize is
      less than the current length the array is cropped with the
      remaining elements retaining their original pointer values. If
      the memory management policy was set to ``PArrayManage``, any
      cropped pointers are deleted.

    .. cpp:function:: void resize(int newsize, PArrayPolicy newmanagedpolicy)

      This function does a resize and changes the memory management
      policy.  (Especially for arrays of PArray where the user wants
      the default policy to be managed--the default constructor makes
      the default unmanaged).  If the new managed policy is different
      from the old one, none of the elements of the original are
      retained.

    .. cpp:function:: T* remove(int i)

      Removes the ``i``'th element from the ``PArray`` and returns the
      pointer to the calling function.  Nulls out the pointer in the
      ``PArray<T>``.

    .. cpp:function:: T* push_back(T* p)

      Pushes a pointer to the back of the array.  This also returns
      the pushed pointer.

  *Example*::

     PArray<MultiFab> mf_parray(4, PArrayManage);
     for (int i = 0; i < 4; ++i) {
         mf_parray.set(i, new MultiFab());
     }
     const MultiFab& mf = mf_parray[3];
     std::cout << "Size of this MultiFab " << mf.size();

PArrayPolicy
************

.. cpp:enum:: PArrayPolicy

  Located in :boxlib:`Src/C_BaseLib/PArray.H`.

  An ``enum`` that controls whether or not ``class PArray<T>`` manages
  the pointed objects. Valid values are 

    * ``PArrayNoManage``
    * ``PArrayManage``.

.. seealso::

  :cpp:class:`Array`

